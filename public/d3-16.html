<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Tree Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f9;
        }
        h1 {
            color: #333;
        }
        #myButtons {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .myButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .myButton:hover {
            transform: translateY(-2px);
        }
        #myLoadButton {
            background-color: #4CAF50;
            color: white;
        }
        #mySaveButton {
            background-color: #2196F3;
            color: white;
        }
        #myAddButton {
            background-color: #9C27B0;
            color: white;
        }
        #myAddLineButton {
            background-color: #FF9800;
            color: white;
        }
        #myFitScreenButton {
            background-color: #FF5722;
            color: white;
        }
        #myTidyUpButton {
            background-color: #6c757d;
            color: white;
        }
        .myButton:active {
            transform: translateY(0);
        }
        .node circle {
            fill: #999;
            stroke: steelblue;
            stroke-width: 3px;
        }
        .node text {
            font-size: 12px;
            font-family: sans-serif;
        }
        .link {
            fill: none;
            stroke: #555;
            stroke-opacity: 0.4;
            stroke-width: 1.5px;
        }
        .arbitrary-link {
            fill: none;
            stroke: #FF9800;
            stroke-dasharray: 5, 5;
            stroke-width: 2px;
        }
        .draggable {
            cursor: grab;
        }
        .dragging {
            cursor: grabbing;
        }
        .selected circle {
            stroke: red;
            stroke-width: 4px;
        }
        .line-text {
            font-size: 10px;
            fill: #FF9800;
            text-anchor: middle; /* Center the text on the path */
        }
        .my-movable-dialog {
            position: absolute;
            bottom: 20px;
            right: 20px;
            min-width: 300px;
            max-width: 90%;
            min-height: 150px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 100;
            display: flex;
            flex-direction: column;
            resize: both;
            overflow: hidden;
        }
        .my-movable-dialog-header {
            padding: 10px;
            background-color: #f0f0f0;
            cursor: grab;
            border-bottom: 1px solid #ccc;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .my-movable-dialog-header:active {
            cursor: grabbing;
        }
        #myFactDisplayArea {
            flex-grow: 1;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            border: none;
            outline: none;
            font-family: monospace;
            resize: none; /* Handled by the parent div */
        }
        .my-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 100;
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .my-dialog input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>

    <h1>D3.js Hierarchical Data Demo</h1>

    <div id="myButtons">
        <input type="file" id="myFileLoad" style="display: none;" onchange="myLoadFile(event)">
        <button class="myButton" id="myLoadButton" onclick="document.getElementById('myFileLoad').click()">Load from JSON</button>
        <button class="myButton" id="mySaveButton" onclick="mySaveData()">Save to JSON</button>
        <button class="myButton" id="myAddButton" onclick="myShowAddNodeDialog()">Add Node</button>
        <button class="myButton" id="myAddLineButton" onclick="myShowAddLineDialog()">Add Line</button>
        <button class="myButton" id="myFitScreenButton" onclick="myFitToScreen()">Fit to Screen</button>
        <button class="myButton" id="myTidyUpButton" onclick="myTidyUpGraph()">Tidy Up</button>
    </div>

    <svg id="mySvgContainer"></svg>

    <!-- Fact Display Dialog -->
    <div id="myFactDialog" class="my-movable-dialog">
        <div id="myFactDialogHeader" class="my-movable-dialog-header">
            Node Fact
        </div>
        <textarea id="myFactDisplayArea" rows="4" readonly placeholder="Click a node to see its fact."></textarea>
    </div>

    <!-- Add Node Dialog -->
    <div id="myAddNodeDialog" class="my-dialog">
        <h3>Add New Node</h3>
        <input type="text" id="myNewNodeName" placeholder="Node Name">
        <input type="text" id="myNewNodeParentId" placeholder="Parent ID">
        <input type="text" id="myNewNodeFact" placeholder="Fact (optional)">
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="myButton" onclick="myAddNewNode()">Add</button>
            <button class="myButton" onclick="document.getElementById('myAddNodeDialog').style.display = 'none'">Cancel</button>
        </div>
    </div>

    <!-- Add Line Dialog -->
    <div id="myAddLineDialog" class="my-dialog">
        <h3>Add New Line</h3>
        <p>Select two nodes on the graph first.</p>
        <input type="text" id="myJoiningFact" placeholder="Joining Fact (optional)">
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="myButton" onclick="myAddLineWithFact()">Add</button>
            <button class="myButton" onclick="document.getElementById('myAddLineDialog').style.display = 'none'">Cancel</button>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global variables for the D3 visualization
        let mySvg, myWidth, myHeight;
        let myTreeLayout;
        let myRootNode;
        let myArbitraryLinks = []; // New array to hold non-hierarchical links
        let myIsDragging = false;
        let mySelectedNodes = []; // Array to track selected nodes for adding lines
        let myZoomBehavior;
        // A D3 line generator for arbitrary links
        const myLineGenerator = d3.line()
            .x(d => d.x)
            .y(d => d.y);

        // Default data in a CSV string format with a 'fact' column
        const myDefaultData = `id,parentId,name,fact
food,,Food,
meat,food,Meat,
carbs,food,Carbs,
veggies,food,Veggies,
salmon,meat,Salmon,
steak,meat,Steak,
chicken,meat,Chicken,"Chickens can fly, but only for short distances. The chicken is the closest living relative of the T-rex."
round,steak,Round,
ribeye,steak,Ribeye,
tbone,steak,T-Bone,`;

        // Run the initialization function when the page loads
        window.onload = function() {
            myWidth = 960;
            myHeight = 600;

            myZoomBehavior = d3.zoom().on("zoom", myZoomed);

            mySvg = d3.select("#mySvgContainer")
                .attr("width", myWidth)
                .attr("height", myHeight)
                .call(myZoomBehavior)
                .append("g");

            // Add a click handler to the SVG background to unselect nodes
            mySvg.on("click", myUnselectAllNodes);

            // Initialize the tree layout
            myTreeLayout = d3.tree()
                .size([myWidth, myHeight - 150]);

            // Load the default data initially
            myDrawData({
                nodes: d3.csvParse(myDefaultData),
                links: []
            });

            // Make the fact dialog movable
            myMakeDraggable("myFactDialog", "myFactDialogHeader");
        };

        // Function to make a dialog draggable
        function myMakeDraggable(dialogId, headerId) {
            const myDialog = document.getElementById(dialogId);
            const myHeader = document.getElementById(headerId);

            myHeader.onmousedown = (e) => {
                e.preventDefault();
                let myOffsetX = e.clientX - myDialog.offsetLeft;
                let myOffsetY = e.clientY - myDialog.offsetTop;
                
                function myMouseMove(e) {
                    myDialog.style.top = (e.clientY - myOffsetY) + 'px';
                    myDialog.style.left = (e.clientX - myOffsetX) + 'px';
                }

                function myMouseUp() {
                    window.removeEventListener('mousemove', myMouseMove);
                    window.removeEventListener('mouseup', myMouseUp);
                }

                window.addEventListener('mousemove', myMouseMove);
                window.addEventListener('mouseup', myMouseUp);
            };
        }

        // Function to handle zooming and panning
        function myZoomed(event) {
            mySvg.attr("transform", event.transform);
        }

        // Function to unselect all nodes
        function myUnselectAllNodes() {
            d3.selectAll('.node.selected').classed('selected', false);
            mySelectedNodes = [];
        }
        
        // Function to reset the graph layout to a clean tree structure
        function myTidyUpGraph() {
            if (!myRootNode) return;
            
            // Re-apply the tree layout to the current root node
            myTreeLayout(myRootNode);

            // Update the visualization to animate nodes back to their calculated positions
            myUpdate(myRootNode);

            myShowMessage("Graph layout has been reset.");
        }

        // Function to fit the graph to the screen
        function myFitToScreen() {
            // Get the bounding box of all nodes and links
            const myNodeElements = d3.selectAll(".node").nodes();
            const myLinkElements = d3.selectAll(".link, .arbitrary-link").nodes();
            
            const allElements = [...myNodeElements, ...myLinkElements];
            if (allElements.length === 0) {
                return;
            }

            const myCombinedBoundingBox = allElements.reduce((box, el) => {
                const b = el.getBBox();
                return {
                    x: Math.min(box.x, b.x),
                    y: Math.min(box.y, b.y),
                    width: Math.max(box.width, b.x + b.width),
                    height: Math.max(box.height, b.y + b.height)
                };
            }, { x: Infinity, y: Infinity, width: -Infinity, height: -Infinity });

            const myScale = Math.min(myWidth / myCombinedBoundingBox.width, myHeight / myCombinedBoundingBox.height) * 0.9;
            const myTranslateX = (myWidth / 2) - (myCombinedBoundingBox.x + myCombinedBoundingBox.width / 2) * myScale;
            const myTranslateY = (myHeight / 2) - (myCombinedBoundingBox.y + myCombinedBoundingBox.height / 2) * myScale;

            d3.select("#mySvgContainer")
                .transition()
                .duration(750)
                .call(myZoomBehavior.transform, d3.zoomIdentity.translate(myTranslateX, myTranslateY).scale(myScale));
        }

        // Function to process and draw the data
        function myDrawData(data) {
            const myRawData = data.nodes;
            myArbitraryLinks = data.links;

            // Stratify the flat data into a hierarchy
            myRootNode = d3.stratify()
                .id(d => d.id)
                .parentId(d => d.parentId)(myRawData);
            
            // Apply the tree layout to generate x and y coordinates
            myTreeLayout(myRootNode);

            // Initialize x0 and y0 for transitions
            myRootNode.descendants().forEach(d => {
                // If a node has stored x/y, use it, otherwise use the tree layout's
                const myLoadedData = myRawData.find(item => item.id === d.id);
                d.x = myLoadedData && myLoadedData.x ? +myLoadedData.x : d.x;
                d.y = myLoadedData && myLoadedData.y ? +myLoadedData.y : d.y;
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Update the visualization
            myUpdate(myRootNode);
        }

        // The core update function to draw or redraw the nodes and links
        function myUpdate(source) {
            const myNodeData = myRootNode.descendants();
            const myTreeLinkData = myRootNode.links();
            const myNodesById = new Map(myNodeData.map(d => [d.id, d]));

            // Create a D3 drag behavior
            const myDragBehavior = d3.drag()
                .on("start", myDragStart)
                .on("drag", myDragged)
                .on("end", myDragEnd);

            // ---- Update the tree links ----
            const myTreeLink = mySvg.selectAll(".link")
                .data(myTreeLinkData, d => d.target.id);

            myTreeLink.enter().append("path")
                .attr("class", "link")
                .attr("d", d3.linkVertical()
                    .x(d => d.x0)
                    .y(d => d.y0))
                .merge(myTreeLink)
                .transition()
                .duration(500)
                .attr("d", d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y));

            // ---- Update the arbitrary links ----
            // Filter out any arbitrary links that don't have corresponding nodes in the current data
            const validArbitraryLinks = myArbitraryLinks.filter(d => myNodesById.has(d.sourceId) && myNodesById.has(d.targetId));
            
            // Paths for the arbitrary links (with unique IDs)
            const myArbitraryLinkPath = mySvg.selectAll(".arbitrary-link")
                .data(validArbitraryLinks, d => `${d.sourceId}-${d.targetId}`);

            myArbitraryLinkPath.enter().append("path")
                .attr("class", "arbitrary-link")
                .attr("id", d => `path-${d.sourceId}-${d.targetId}`) // Give the path an ID
                .attr("d", d => myLineGenerator([myNodesById.get(d.sourceId), myNodesById.get(d.targetId)]))
                .merge(myArbitraryLinkPath)
                .attr("d", d => myLineGenerator([myNodesById.get(d.sourceId), myNodesById.get(d.targetId)]));
                
            // Text for the arbitrary links
            const myArbitraryLinkText = mySvg.selectAll(".line-text")
                .data(validArbitraryLinks, d => `text-${d.sourceId}-${d.targetId}`);

            myArbitraryLinkText.enter().append("text")
                .attr("class", "line-text")
                .merge(myArbitraryLinkText)
                .html(d => `<textPath href="#path-${d.sourceId}-${d.targetId}" startOffset="50%">${d.joiningFact}</textPath>`);

            myArbitraryLinkText.exit().remove();
            
            // ---- Update the nodes ----
            const myNode = mySvg.selectAll(".node")
                .data(myNodeData, d => d.id);

            // Enter any new nodes
            const myNodeEnter = myNode.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${source.x0},${source.y0})`)
                .on("click", myClickNode);

            // Add circles to the new nodes
            myNodeEnter.append("circle")
                .attr("r", 10)
                .style("fill", d => d._children ? "lightsteelblue" : "#fff");

            // Add text labels to the new nodes
            myNodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children || d.data.children ? -15 : 15)
                .attr("text-anchor", d => d._children || d.data.children ? "end" : "start")
                .text(d => d.data.name);

            // Merge new nodes with the existing ones
            const myNodeUpdate = myNodeEnter.merge(myNode);

            // Transition nodes to their new positions
            myNodeUpdate.transition()
                .duration(500)
                .attr("transform", d => `translate(${d.x},${d.y})`);

            // Apply drag behavior to the nodes
            myNodeUpdate.call(myDragBehavior);

            // Store the old positions for animation
            myNodeData.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        // Drag functions
        function myDragStart(event, d) {
            myIsDragging = true;
            d3.select(this).raise().classed("dragging", true); // Raise the node to the top
        }

        function myDragged(event, d) {
            d.x = event.x;
            d.y = event.y;
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
        }

        function myDragEnd(event, d) {
            myIsDragging = false;
            d3.select(this).classed("dragging", false);
            myUpdate(d); // Redraw the graph from the perspective of the dragged node
        }

        // Function to handle clicking on a node
        function myClickNode(event, d) {
            // Stop the event propagation to prevent it from reaching the SVG background
            event.stopPropagation();

            // If a drag is in progress, do nothing
            if (myIsDragging) return;

            // Check if the Ctrl key is held down for selection
            if (event.ctrlKey) {
                // Toggle selection on the node
                const myIndex = mySelectedNodes.indexOf(d);
                if (myIndex > -1) {
                    mySelectedNodes.splice(myIndex, 1);
                    d3.select(event.currentTarget).classed('selected', false);
                } else {
                    mySelectedNodes.push(d);
                    d3.select(event.currentTarget).classed('selected', true);
                }
            } else {
                // If Ctrl is not pressed, unselect all and just display the fact
                myUnselectAllNodes();
                if (d.data.fact) {
                    myShowMessage(d.data.fact);
                } else {
                    myShowMessage("No fact available for this node.");
                }
            }
        }

        // Function to show the "Add Line" dialog
        function myShowAddLineDialog() {
            if (mySelectedNodes.length < 2) {
                myShowMessage("Please select at least two nodes to add a line.");
                return;
            }
            document.getElementById('myAddLineDialog').style.display = 'flex';
        }

        // Function to add a new line with a fact
        function myAddLineWithFact() {
            const myJoiningFact = document.getElementById('myJoiningFact').value;

            if (mySelectedNodes.length < 2) {
                myShowMessage("Please select at least two nodes.");
                return;
            }

            const mySourceNode = mySelectedNodes[0];
            const myTargetNodes = mySelectedNodes.slice(1);

            for (const myTargetNode of myTargetNodes) {
                // Prevent self-linking and duplicates
                if (mySourceNode.id === myTargetNode.id) continue;
                
                const myExistingLink = myArbitraryLinks.find(
                    link => (link.sourceId === mySourceNode.id && link.targetId === myTargetNode.id) ||
                            (link.sourceId === myTargetNode.id && link.targetId === mySourceNode.id)
                );
                if (myExistingLink) continue;

                myArbitraryLinks.push({ 
                    sourceId: mySourceNode.id, 
                    targetId: myTargetNode.id,
                    joiningFact: myJoiningFact
                });
            }

            // Redraw the graph with the new link and fact
            myUpdate(myRootNode);

            // Clear the selection
            document.getElementById('myAddLineDialog').style.display = 'none';
            document.getElementById('myJoiningFact').value = '';
            myUnselectAllNodes();
            myShowMessage(`Added a new line.${myJoiningFact ? ` with fact: "${myJoiningFact}"` : ""}`);
        }

        // Function to display messages in the text area
        function myShowMessage(message) {
            document.getElementById("myFactDisplayArea").value = message;
        }

        // Function to show the "Add Node" dialog
        function myShowAddNodeDialog() {
            if (mySelectedNodes.length === 1) {
                document.getElementById('myNewNodeParentId').value = mySelectedNodes[0].id;
                document.getElementById('myAddNodeDialog').style.display = 'flex';
            } else if (mySelectedNodes.length === 0) {
                myShowMessage("Please select a single node to be the parent of the new node.");
            } else {
                myShowMessage("Please select ONLY one node to add a child node to.");
            }
        }

        // Function to add a new node
        function myAddNewNode() {
            const myNewNodeName = document.getElementById('myNewNodeName').value;
            const myNewNodeParentId = document.getElementById('myNewNodeParentId').value;
            const myNewNodeFact = document.getElementById('myNewNodeFact').value;

            if (!myNewNodeName || !myNewNodeParentId) {
                myShowMessage("Node Name and Parent ID are required.");
                return;
            }

            const myRawData = myRootNode.descendants().map(d => d.data);
            const myParentNode = myRawData.find(d => d.id === myNewNodeParentId);
            if (!myParentNode) {
                myShowMessage("Parent node not found with the given ID.");
                return;
            }

            const myNewNodeId = myNewNodeName.toLowerCase().replace(/\s/g, '');
            const myNewDataPoint = {
                id: myNewNodeId,
                parentId: myNewNodeParentId,
                name: myNewNodeName,
                fact: myNewNodeFact || ""
            };

            myRawData.push(myNewDataPoint);

            myDrawData({
                nodes: myRawData,
                links: myArbitraryLinks
            });
            
            document.getElementById('myAddNodeDialog').style.display = 'none';
            document.getElementById('myNewNodeName').value = '';
            document.getElementById('myNewNodeParentId').value = '';
            document.getElementById('myNewNodeFact').value = '';
            myUnselectAllNodes();
        }

        // Function to handle the file upload
        function myLoadFile(event) {
            const myFile = event.target.files[0];
            if (!myFile) {
                return;
            }
            const myReader = new FileReader();
            myReader.onload = function(e) {
                try {
                    const myJsonContent = JSON.parse(e.target.result);
                    myDrawData(myJsonContent);
                    myShowMessage("File loaded successfully!");
                } catch (error) {
                    myShowMessage("Error loading file. Please ensure it is a valid JSON file.");
                }
            };
            myReader.readAsText(myFile);
        }
        
        // Function to create a link and download the data
        function mySaveData() {
            const mySavedNodes = myRootNode.descendants().map(d => {
                return {
                    id: d.id,
                    parentId: d.parent ? d.parent.id : "",
                    name: d.data.name,
                    fact: d.data.fact || "",
                    x: d.x,
                    y: d.y
                };
            });

            const myDataToSave = {
                nodes: mySavedNodes,
                links: myArbitraryLinks
            };

            const myJson = JSON.stringify(myDataToSave, null, 2);
            const myBlob = new Blob([myJson], { type: "application/json" });
            const myUrl = URL.createObjectURL(myBlob);
            const myLink = document.createElement("a");
            myLink.setAttribute("href", myUrl);
            myLink.setAttribute("download", "d3_graph_data.json");
            myLink.style.display = "none";
            document.body.appendChild(myLink);
            myLink.click();
            document.body.removeChild(myLink);
            myShowMessage("Graph saved to d3_graph_data.json!");
        }
    </script>
</body>
</html>
