<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3.js Tree Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f9;
        }
        h1 {
            color: #333;
        }
        #myButtons {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        .myButton {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .myButton:hover {
            transform: translateY(-2px);
        }
        #myLoadButton {
            background-color: #4CAF50;
            color: white;
        }
        #mySaveButton {
            background-color: #2196F3;
            color: white;
        }
        #myAddButton {
            background-color: #9C27B0;
            color: white;
        }
        #myFitScreenButton {
            background-color: #FF5722;
            color: white;
        }
        .myButton:active {
            transform: translateY(0);
        }
        #myMessageContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
            display: none;
        }
        .closeButton {
            float: right;
            cursor: pointer;
            font-weight: bold;
            font-size: 20px;
            line-height: 1;
        }
        .node circle {
            fill: #999;
            stroke: steelblue;
            stroke-width: 3px;
        }
        .node text {
            font-size: 12px;
            font-family: sans-serif;
        }
        .link {
            fill: none;
            stroke: #555;
            stroke-opacity: 0.4;
            stroke-width: 1.5px;
        }
        .draggable {
            cursor: grab;
        }
        .dragging {
            cursor: grabbing;
        }
        #myAddNodeDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 100;
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        #myAddNodeDialog input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>

    <h1>D3.js Hierarchical Data Demo</h1>

    <div id="myButtons">
        <input type="file" id="myFileLoad" style="display: none;" onchange="myLoadFile(event)">
        <button class="myButton" id="myLoadButton" onclick="document.getElementById('myFileLoad').click()">Load from CSV</button>
        <button class="myButton" id="mySaveButton" onclick="mySaveData()">Save to CSV</button>
        <button class="myButton" id="myAddButton" onclick="myShowAddNodeDialog()">Add Node</button>
        <button class="myButton" id="myFitScreenButton" onclick="myFitToScreen()">Fit to Screen</button>
    </div>

    <svg id="mySvgContainer"></svg>

    <div id="myMessageContainer">
        <span class="closeButton" onclick="myCloseMessage()">&times;</span>
        <h3 id="myMessageTitle"></h3>
        <p id="myMessageContent"></p>
    </div>

    <div id="myAddNodeDialog">
        <h3>Add New Node</h3>
        <input type="text" id="myNewNodeName" placeholder="Node Name">
        <input type="text" id="myNewNodeParentId" placeholder="Parent ID">
        <input type="text" id="myNewNodeFact" placeholder="Fact (optional)">
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="myButton" onclick="myAddNewNode()">Add</button>
            <button class="myButton" onclick="document.getElementById('myAddNodeDialog').style.display = 'none'">Cancel</button>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Global variables for the D3 visualization
        let mySvg, myWidth, myHeight;
        let myTreeLayout;
        let myRootNode; // This variable is now global
        let myIsDragging = false;
        
        // Default data in a CSV string format with a 'fact' column
        const myDefaultData = `id,parentId,name,fact
food,,Food,
meat,food,Meat,
carbs,food,Carbs,
veggies,food,Veggies,
salmon,meat,Salmon,
steak,meat,Steak,
chicken,meat,Chicken,"Chickens can fly, but only for short distances. The chicken is the closest living relative of the T-rex."
round,steak,Round,
ribeye,steak,Ribeye,
tbone,steak,T-Bone,`;

        // Run the initialization function when the page loads
        window.onload = function() {
            myWidth = 960;
            myHeight = 600;

            mySvg = d3.select("#mySvgContainer")
                .attr("width", myWidth)
                .attr("height", myHeight)
                .call(d3.zoom().on("zoom", myZoomed))
                .append("g");

            // Initialize the tree layout
            myTreeLayout = d3.tree()
                .size([myWidth, myHeight - 150]);

            // Load the default data initially
            myDrawData(myDefaultData);
        };

        // Function to handle zooming and panning
        function myZoomed(event) {
            mySvg.attr("transform", event.transform);
        }
        
        // Function to fit the graph to the screen
        function myFitToScreen() {
            const myBoundingBox = mySvg.node().getBBox();
            if (myBoundingBox.width === 0 || myBoundingBox.height === 0) {
                return; // Do nothing if there are no nodes
            }
            const myScale = Math.min(myWidth / myBoundingBox.width, myHeight / myBoundingBox.height) * 0.8; // 80% to leave some padding
            const myTranslateX = (myWidth / 2) - (myBoundingBox.x + myBoundingBox.width / 2) * myScale;
            const myTranslateY = (myHeight / 2) - (myBoundingBox.y + myBoundingBox.height / 2) * myScale;
            
            d3.select("#mySvgContainer")
                .transition()
                .duration(750)
                .call(d3.zoom().scaleExtent([0.1, 4]).transform, d3.zoomIdentity.translate(myTranslateX, myTranslateY).scale(myScale));
        }

        // Function to process and draw the data
        function myDrawData(csvString) {
            // First, parse the CSV data
            const myRawData = d3.csvParse(csvString);

            // Stratify the flat data into a hierarchy and assign to the global variable
            myRootNode = d3.stratify()
                .id(d => d.id)
                .parentId(d => d.parentId)(myRawData);
            
            // If the loaded data has x and y positions, use them
            myRootNode.each(d => {
                const myLoadedData = myRawData.find(item => item.id === d.id);
                if (myLoadedData && myLoadedData.x && myLoadedData.y) {
                    d.x = +myLoadedData.x;
                    d.y = +myLoadedData.y;
                }
                d.x0 = d.x;
                d.y0 = d.y;
            });

            // Recompute the tree layout
            myTreeLayout(myRootNode);

            // Update the visualization
            myUpdate(myRootNode);
        }

        // The core update function to draw or redraw the nodes and links
        function myUpdate(source) {
            const myNodeData = myRootNode.descendants();
            const myLinkData = myRootNode.links();

            // Create a D3 drag behavior
            const myDragBehavior = d3.drag()
                .on("start", myDragStart)
                .on("drag", myDragged)
                .on("end", myDragEnd);

            // ---- Update the links ----
            const myLink = mySvg.selectAll(".link")
                .data(myLinkData, d => d.target.id);

            // Enter any new links
            myLink.enter().append("path")
                .attr("class", "link")
                .attr("d", d3.linkVertical()
                    .x(d => d.x0)
                    .y(d => d.y0));

            // Transition links to their new positions
            mySvg.selectAll(".link").transition()
                .duration(500)
                .attr("d", d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y));

            // ---- Update the nodes ----
            const myNode = mySvg.selectAll(".node")
                .data(myNodeData, d => d.id);

            // Enter any new nodes
            const myNodeEnter = myNode.enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${source.x0},${source.y0})`)
                .on("click", myClickNode);

            // Add circles to the new nodes
            myNodeEnter.append("circle")
                .attr("r", 10)
                .style("fill", d => d._children ? "lightsteelblue" : "#fff");

            // Add text labels to the new nodes
            myNodeEnter.append("text")
                .attr("dy", "0.31em")
                .attr("x", d => d._children || d.data.children ? -15 : 15)
                .attr("text-anchor", d => d._children || d.data.children ? "end" : "start")
                .text(d => d.data.name);

            // Merge new nodes with the existing ones
            const myNodeUpdate = myNodeEnter.merge(myNode);

            // Transition nodes to their new positions
            myNodeUpdate.transition()
                .duration(500)
                .attr("transform", d => `translate(${d.x},${d.y})`);

            // Apply drag behavior to the nodes
            myNodeUpdate.call(myDragBehavior);

            // Store the old positions for animation
            myNodeData.forEach(d => {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }
        
        // Drag functions
        function myDragStart(event, d) {
            myIsDragging = true;
            d3.select(this).classed("dragging", true);
        }

        function myDragged(event, d) {
            d.x = event.x;
            d.y = event.y;
            d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            myUpdate(d);
        }

        function myDragEnd(event, d) {
            myIsDragging = false;
            d3.select(this).classed("dragging", false);
            // D3's tree layout already updates the x and y positions. We just need to save them.
        }

        // Function to handle clicking on a node
        function myClickNode(event, d) {
            // Prevent toggling children if we are in the middle of a drag
            if (myIsDragging) return;

            // Check if the node has a fact and show it
            if (d.data.fact) {
                myShowNodeFact(d.data.fact);
                return;
            }

            // Otherwise, toggle the children
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            myUpdate(d);
        }

        // Function to display random chicken facts
        function myShowNodeFact(fact) {
            document.getElementById("myMessageTitle").innerText = "Fact";
            document.getElementById("myMessageContent").innerText = fact;
            document.getElementById("myMessageContainer").style.display = "block";
        }

        // Function to close the message box
        function myCloseMessage() {
            document.getElementById("myMessageContainer").style.display = "none";
        }

        // Function to show the "Add Node" dialog
        function myShowAddNodeDialog() {
            document.getElementById('myAddNodeDialog').style.display = 'flex';
        }

        // Function to add a new node
        function myAddNewNode() {
            const myNewNodeName = document.getElementById('myNewNodeName').value;
            const myNewNodeParentId = document.getElementById('myNewNodeParentId').value;
            const myNewNodeFact = document.getElementById('myNewNodeFact').value;

            if (!myNewNodeName || !myNewNodeParentId) {
                myShowNodeFact("Node Name and Parent ID are required.");
                return;
            }

            // Find the parent node to add the new child to
            const myParentNode = myRootNode.descendants().find(d => d.id === myNewNodeParentId);
            if (!myParentNode) {
                myShowNodeFact("Parent node not found with the given ID.");
                return;
            }

            const myNewNodeId = myNewNodeName.toLowerCase().replace(/\s/g, '');
            const myNewDataPoint = {
                id: myNewNodeId,
                parentId: myNewNodeParentId,
                name: myNewNodeName,
                fact: myNewNodeFact || ""
            };

            // Update the underlying data
            const myRawData = myRootNode.descendants().map(d => d.data);
            myRawData.push(myNewDataPoint);

            // Re-draw the entire tree with the new data
            myDrawData(d3.csvFormat(myRawData));
            
            // Hide the dialog and clear the inputs
            document.getElementById('myAddNodeDialog').style.display = 'none';
            document.getElementById('myNewNodeName').value = '';
            document.getElementById('myNewNodeParentId').value = '';
            document.getElementById('myNewNodeFact').value = '';
        }

        // Function to handle the file upload
        function myLoadFile(event) {
            const myFile = event.target.files[0];
            if (!myFile) {
                return;
            }
            const myReader = new FileReader();
            myReader.onload = function(e) {
                const myCsvContent = e.target.result;
                myDrawData(myCsvContent);
            };
            myReader.readAsText(myFile);
        }
        
        // Function to create a link and download the data
        function mySaveData() {
            // Re-create the CSV string from the current node positions
            const mySavedData = myRootNode.descendants().map(d => {
                return {
                    id: d.id,
                    parentId: d.parent ? d.parent.id : "",
                    name: d.data.name,
                    fact: d.data.fact || "", // Include the fact field
                    x: d.x,
                    y: d.y
                };
            });

            // Convert to CSV string format
            const myCsv = d3.csvFormat(mySavedData, ["id", "parentId", "name", "fact", "x", "y"]);
            const myBlob = new Blob([myCsv], { type: "text/csv;charset=utf-8;" });
            const myUrl = URL.createObjectURL(myBlob);
            const myLink = document.createElement("a");
            myLink.setAttribute("href", myUrl);
            myLink.setAttribute("download", "d3_tree_data.csv");
            myLink.style.display = "none";
            document.body.appendChild(myLink);
            myLink.click();
            document.body.removeChild(myLink);
        }
    </script>
</body>
</html>
